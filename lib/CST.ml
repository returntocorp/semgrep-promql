(* Generated by ocaml-tree-sitter. *)
(*
   promql grammar

   entrypoint: query_
*)

open! Sexplib.Conv
open Tree_sitter_run

type pat_db4e4e9 =
  Token.t (* pattern [-+]?([0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?|0[xX][0-9a-fA-F]+|[nN][aA][nN]|[iI][nN][fF]) *)

type semgrep_metavariable = Token.t

type pat_dcab316 = Token.t (* pattern [1-9][0-9]* *)

type double_quoted_string = Token.t

type identifier = Token.t (* pattern [a-zA-Z_:][a-zA-Z0-9_:]* *)

type single_quoted_string = Token.t

type pat_780550e = Token.t (* pattern [0-9]+ *)

type float_literal = [
    `Semg_meta of semgrep_metavariable (*tok*)
  | `Pat_db4e4e9 of pat_db4e4e9
]

type at = (
    Token.t (* "@" *)
  * [
        `Star of Token.t (* "start()" *)
      | `EndL of Token.t (* "end()" *)
      | `Pat_dcab316 of pat_dcab316
    ]
)

type function_name = [
    `Semg_meta of semgrep_metavariable (*tok*)
  | `Id of identifier (*tok*)
]

type label_name = [
    `Semg_meta of semgrep_metavariable (*tok*)
  | `Id of identifier (*tok*)
]

type metric_name = [
    `Semg_meta of semgrep_metavariable (*tok*)
  | `Id of identifier (*tok*)
]

type quoted_string = [
    `Single_quoted_str of single_quoted_string (*tok*)
  | `Double_quoted_str of double_quoted_string (*tok*)
]

type duration =
  (
      pat_780550e
    * [
          `Ms of Token.t (* "ms" *)
        | `S of Token.t (* "s" *)
        | `M of Token.t (* "m" *)
        | `H of Token.t (* "h" *)
        | `D of Token.t (* "d" *)
        | `W of Token.t (* "w" *)
        | `Y of Token.t (* "y" *)
      ]
  )
    list (* one or more *)

type anon_label_name_rep_COMMA_label_name_opt_COMMA_84ead0c = (
    label_name
  * (Token.t (* "," *) * label_name) list (* zero or more *)
  * Token.t (* "," *) option
)

type string_literal = [
    `Semg_meta of semgrep_metavariable (*tok*)
  | `Quoted_str of quoted_string
]

type label_value = [
    `Semg_meta of semgrep_metavariable (*tok*)
  | `Quoted_str of quoted_string
]

type subquery_range_selection = (
    Token.t (* "[" *)
  * duration
  * Token.t (* ":" *)
  * duration option
  * Token.t (* "]" *)
)

type range_selection = (Token.t (* "[" *) * duration * Token.t (* "]" *))

type offset = (Token.t (* "offset" *) * Token.t (* "-" *) option * duration)

type binary_grouping = (
    [ `On of Token.t (* "on" *) | `Igno of Token.t (* "ignoring" *) ]
  * Token.t (* "(" *)
  * anon_label_name_rep_COMMA_label_name_opt_COMMA_84ead0c option
  * Token.t (* ")" *)
  * (
        [
            `Group_left of Token.t (* "group_left" *)
          | `Group_right of Token.t (* "group_right" *)
        ]
      * (
            Token.t (* "(" *)
          * anon_label_name_rep_COMMA_label_name_opt_COMMA_84ead0c option
          * Token.t (* ")" *)
        )
          option
    )
      option
)

type grouping = (
    [ `By of Token.t (* "by" *) | `With of Token.t (* "without" *) ]
  * Token.t (* "(" *)
  * anon_label_name_rep_COMMA_label_name_opt_COMMA_84ead0c option
  * Token.t (* ")" *)
)

type literal_expression = [
    `Float_lit of float_literal
  | `Str_lit of string_literal
]

type label_matcher = (
    label_name
  * [
        `EQ of Token.t (* "=" *)
      | `BANGEQ of Token.t (* "!=" *)
      | `EQTILDE of Token.t (* "=~" *)
      | `BANGTILDE of Token.t (* "!~" *)
    ]
  * label_value
)

type modifier = [
    `Offset_opt_at of (offset * at option)
  | `At_opt_offset of (at * offset option)
]

type label_selectors = (
    Token.t (* "{" *)
  * (
        label_matcher
      * (Token.t (* "," *) * label_matcher) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* "}" *)
)

type series_matcher = (metric_name * label_selectors option)

type range_vector_selector = [
    `Semg_meta of semgrep_metavariable (*tok*)
  | `Series_matc_range_sele_opt_modi of (
        series_matcher
      * range_selection
      * modifier option
    )
]

type instant_vector_selector = [
    `Semg_meta of semgrep_metavariable (*tok*)
  | `Series_matc_opt_modi of (series_matcher * modifier option)
]

type selector_expression = [
    `Inst_vec_sele of instant_vector_selector
  | `Range_vec_sele of range_vector_selector
]

type binary_expression = [
    `Query_choice_HAT_opt_bin_grou_query of (
        query_
      * [ `HAT of Token.t (* "^" *) ]
      * binary_grouping option
      * query_
    )
  | `Query_choice_STAR_opt_bin_grou_query of (
        query_
      * [
            `STAR of Token.t (* "*" *)
          | `SLASH of Token.t (* "/" *)
          | `PERC of Token.t (* "%" *)
        ]
      * binary_grouping option
      * query_
    )
  | `Query_choice_PLUS_opt_bin_grou_query of (
        query_
      * [ `PLUS of Token.t (* "+" *) | `DASH of Token.t (* "-" *) ]
      * binary_grouping option
      * query_
    )
  | `Query_choice_EQEQ_opt_bool_opt_bin_grou_query of (
        query_
      * [
            `EQEQ of Token.t (* "==" *)
          | `BANGEQ of Token.t (* "!=" *)
          | `GT of Token.t (* ">" *)
          | `GTEQ of Token.t (* ">=" *)
          | `LT of Token.t (* "<" *)
          | `LTEQ of Token.t (* "<=" *)
        ]
      * Token.t (* "bool" *) option
      * binary_grouping option
      * query_
    )
  | `Query_choice_and_opt_bin_grou_query of (
        query_
      * [
            `And of Token.t (* "and" *)
          | `Or of Token.t (* "or" *)
          | `Unless of Token.t (* "unless" *)
        ]
      * binary_grouping option
      * query_
    )
  | `Query_choice_atan2_opt_bin_grou_query of (
        query_
      * [ `Atan2 of Token.t (* "atan2" *) ]
      * binary_grouping option
      * query_
    )
]

and call_expression = function_call

and function_args = (
    Token.t (* "(" *)
  * (
        query_
      * (Token.t (* "," *) * query_) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* ")" *)
)

and function_call = [
    `Func_name_func_args of (function_name * function_args)
  | `Func_name_grou_func_args of (function_name * grouping * function_args)
  | `Func_name_func_args_grou of (function_name * function_args * grouping)
]

and operator_expression = binary_expression

and query = [
    `Query_exp of query_expression
  | `LPAR_query_exp_RPAR of (
        Token.t (* "(" *) * query_expression * Token.t (* ")" *)
    )
]

and query_ = query

and query_expression = [
    `Lit_exp of literal_expression
  | `Sele_exp of selector_expression
  | `Call_exp of call_expression
  | `Op_exp of operator_expression
  | `Subq_exp of (query_ * subquery_range_selection * modifier option)
]

and subquery = (query_ * subquery_range_selection * modifier option)

type comment (* inlined *) = Token.t

type subquery_expression (* inlined *) = subquery
