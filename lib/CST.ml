(* Generated by ocaml-tree-sitter. *)
(*
   promql grammar

   entrypoint: query_
*)

open! Sexplib.Conv
open Tree_sitter_run

type pat_780550e = Token.t (* pattern [0-9]+ *)

type semgrep_metavariable = Token.t

type identifier = Token.t (* pattern [a-zA-Z_:][a-zA-Z0-9_:]* *)

type float_literal =
  Token.t (* pattern [-+]?([0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?|0[xX][0-9a-fA-F]+|[nN][aA][nN]|[iI][nN][fF]) *)

type pat_dcab316 = Token.t (* pattern [1-9][0-9]* *)

type single_quoted_string = Token.t

type double_quoted_string = Token.t

type aggregation_operator = [
    `Sum of Token.t (* "sum" *)
  | `Max of Token.t (* "max" *)
  | `Min of Token.t (* "min" *)
  | `Avg of Token.t (* "avg" *)
  | `Group of Token.t (* "group" *)
  | `Stddev of Token.t (* "stddev" *)
  | `Stdvar of Token.t (* "stdvar" *)
  | `Count of Token.t (* "count" *)
  | `Count_values of Token.t (* "count_values" *)
  | `Bott of Token.t (* "bottomk" *)
  | `Topk of Token.t (* "topk" *)
  | `Quan of Token.t (* "quantile" *)
]

type duration =
  (
      pat_780550e
    * [
          `Ms of Token.t (* "ms" *)
        | `S of Token.t (* "s" *)
        | `M of Token.t (* "m" *)
        | `H of Token.t (* "h" *)
        | `D of Token.t (* "d" *)
        | `W of Token.t (* "w" *)
        | `Y of Token.t (* "y" *)
      ]
  )
    list (* one or more *)

type metric_name = [
    `Semg_meta of semgrep_metavariable (*tok*)
  | `Id of identifier (*tok*)
]

type label_name = [
    `Semg_meta of semgrep_metavariable (*tok*)
  | `Id of identifier (*tok*)
]

type function_name = [
    `Semg_meta of semgrep_metavariable (*tok*)
  | `Id of identifier (*tok*)
]

type at = (
    Token.t (* "@" *)
  * [
        `Star of Token.t (* "start()" *)
      | `EndL of Token.t (* "end()" *)
      | `Pat_dcab316 of pat_dcab316
    ]
)

type quoted_string = [
    `Single_quoted_str of single_quoted_string (*tok*)
  | `Double_quoted_str of double_quoted_string (*tok*)
]

type subquery_range_selection = (
    Token.t (* "[" *)
  * duration
  * Token.t (* ":" *)
  * duration option
  * Token.t (* "]" *)
)

type range_selection = (Token.t (* "[" *) * duration * Token.t (* "]" *))

type offset = (Token.t (* "offset" *) * Token.t (* "-" *) option * duration)

type anon_label_name_rep_COMMA_label_name_opt_COMMA_84ead0c = (
    label_name
  * (Token.t (* "," *) * label_name) list (* zero or more *)
  * Token.t (* "," *) option
)

type string_literal = quoted_string

type modifier = [
    `Offset_opt_at of (offset * at option)
  | `At_opt_offset of (at * offset option)
]

type aggregation_grouping = (
    [ `By of Token.t (* "by" *) | `With of Token.t (* "without" *) ]
  * Token.t (* "(" *)
  * anon_label_name_rep_COMMA_label_name_opt_COMMA_84ead0c option
  * Token.t (* ")" *)
)

type binary_grouping = (
    [ `On of Token.t (* "on" *) | `Igno of Token.t (* "ignoring" *) ]
  * Token.t (* "(" *)
  * anon_label_name_rep_COMMA_label_name_opt_COMMA_84ead0c option
  * Token.t (* ")" *)
  * (
        [
            `Group_left of Token.t (* "group_left" *)
          | `Group_right of Token.t (* "group_right" *)
        ]
      * (
            Token.t (* "(" *)
          * anon_label_name_rep_COMMA_label_name_opt_COMMA_84ead0c option
          * Token.t (* ")" *)
        )
          option
    )
      option
)

type label_value = [
    `Semg_meta of semgrep_metavariable (*tok*)
  | `Quoted_str of string_literal
]

type literal_expression = [
    `Float_lit of float_literal (*tok*)
  | `Str_lit of string_literal
]

type label_matcher = (
    label_name
  * [
        `EQ of Token.t (* "=" *)
      | `BANGEQ of Token.t (* "!=" *)
      | `EQTILDE of Token.t (* "=~" *)
      | `BANGTILDE of Token.t (* "!~" *)
    ]
  * label_value
)

type label_selectors = (
    Token.t (* "{" *)
  * (
        label_matcher
      * (Token.t (* "," *) * label_matcher) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* "}" *)
)

type series_matcher = (metric_name * label_selectors option)

type timeseries_selector_expression = [
    `Inst_vec_sele of (series_matcher * modifier option)
  | `Range_vec_sele of (series_matcher * range_selection * modifier option)
]

type binary_expression = [
    `Query_choice_HAT_opt_bin_grou_query of (
        query_
      * [ `HAT of Token.t (* "^" *) ]
      * binary_grouping option
      * query_
    )
  | `Query_choice_STAR_opt_bin_grou_query of (
        query_
      * [
            `STAR of Token.t (* "*" *)
          | `SLASH of Token.t (* "/" *)
          | `PERC of Token.t (* "%" *)
        ]
      * binary_grouping option
      * query_
    )
  | `Query_choice_PLUS_opt_bin_grou_query of (
        query_
      * [ `PLUS of Token.t (* "+" *) | `DASH of Token.t (* "-" *) ]
      * binary_grouping option
      * query_
    )
  | `Query_choice_EQEQ_opt_bool_opt_bin_grou_query of (
        query_
      * [
            `EQEQ of Token.t (* "==" *)
          | `BANGEQ of Token.t (* "!=" *)
          | `GT of Token.t (* ">" *)
          | `GTEQ of Token.t (* ">=" *)
          | `LT of Token.t (* "<" *)
          | `LTEQ of Token.t (* "<=" *)
        ]
      * Token.t (* "bool" *) option
      * binary_grouping option
      * query_
    )
  | `Query_choice_and_opt_bin_grou_query of (
        query_
      * [
            `And of Token.t (* "and" *)
          | `Or of Token.t (* "or" *)
          | `Unless of Token.t (* "unless" *)
        ]
      * binary_grouping option
      * query_
    )
  | `Query_choice_atan2_opt_bin_grou_query of (
        query_
      * [ `Atan2 of Token.t (* "atan2" *) ]
      * binary_grouping option
      * query_
    )
]

and function_args = (
    Token.t (* "(" *)
  * (
        query_
      * (Token.t (* "," *) * query_) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* ")" *)
)

and function_call = (function_name * function_args)

and operator_expression = [
    `Aggr_exp of (
        aggregation_operator
      * aggregation_grouping option
      * Token.t (* "(" *)
      * (literal_expression * Token.t (* "," *)) option
      * query_
      * Token.t (* ")" *)
      * aggregation_grouping option
    )
  | `Bin_exp of binary_expression
]

and query = [
    `Query_exp of query_expression
  | `LPAR_query_exp_RPAR of (
        Token.t (* "(" *) * query_expression * Token.t (* ")" *)
    )
]

and query_ = query

and query_expression = [
    `Lit_exp of literal_expression
  | `Timess_sele_exp of timeseries_selector_expression
  | `Func_exp of (function_name * function_args)
  | `Op_exp of operator_expression
  | `Subq_exp of (query_ * subquery_range_selection * modifier option)
]

and subquery = (query_ * subquery_range_selection * modifier option)

type comment (* inlined *) = Token.t

type range_vector_selector (* inlined *) = (
    series_matcher
  * range_selection
  * modifier option
)

type instant_vector_selector (* inlined *) = (
    series_matcher
  * modifier option
)

type aggregation_expression (* inlined *) = (
    aggregation_operator
  * aggregation_grouping option
  * Token.t (* "(" *)
  * (literal_expression * Token.t (* "," *)) option
  * query_
  * Token.t (* ")" *)
  * aggregation_grouping option
)

type function_expression (* inlined *) = function_call

type subquery_expression (* inlined *) = subquery
